{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar _extends = require('@babel/runtime/helpers/extends');\n\nvar _inheritsLoose = require('@babel/runtime/helpers/inheritsLoose');\n\nvar React = require('react');\n\nvar PropTypes = require('prop-types');\n\nfunction _interopDefault(e) {\n  return e && e.__esModule ? e : {\n    'default': e\n  };\n}\n\nvar _extends__default = /*#__PURE__*/_interopDefault(_extends);\n\nvar _inheritsLoose__default = /*#__PURE__*/_interopDefault(_inheritsLoose);\n\nvar React__default = /*#__PURE__*/_interopDefault(React);\n\nvar PropTypes__default = /*#__PURE__*/_interopDefault(PropTypes);\n\nvar _jsxFileName = \"/Users/krise/github/react-slider/src/components/ReactSlider/ReactSlider.jsx\";\n/**\n * To prevent text selection while dragging.\n * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\n */\n\nfunction pauseEvent(e) {\n  if (e && e.stopPropagation) {\n    e.stopPropagation();\n  }\n\n  if (e && e.preventDefault) {\n    e.preventDefault();\n  }\n\n  return false;\n}\n\nfunction stopPropagation(e) {\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  }\n}\n\nfunction sanitizeInValue(x) {\n  if (x == null) {\n    return [];\n  }\n\n  return Array.isArray(x) ? x.slice() : [x];\n}\n\nfunction prepareOutValue(x) {\n  return x !== null && x.length === 1 ? x[0] : x.slice();\n}\n\nfunction trimSucceeding(length, nextValue, minDistance, max) {\n  for (var i = 0; i < length; i += 1) {\n    var padding = max - i * minDistance;\n\n    if (nextValue[length - 1 - i] > padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[length - 1 - i] = padding;\n    }\n  }\n}\n\nfunction trimPreceding(length, nextValue, minDistance, min) {\n  for (var i = 0; i < length; i += 1) {\n    var padding = min + i * minDistance;\n\n    if (nextValue[i] < padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[i] = padding;\n    }\n  }\n}\n\nfunction addHandlers(eventMap) {\n  Object.keys(eventMap).forEach(function (key) {\n    if (typeof document !== 'undefined') {\n      document.addEventListener(key, eventMap[key], false);\n    }\n  });\n}\n\nfunction removeHandlers(eventMap) {\n  Object.keys(eventMap).forEach(function (key) {\n    if (typeof document !== 'undefined') {\n      document.removeEventListener(key, eventMap[key], false);\n    }\n  });\n}\n\nfunction trimAlignValue(val, props) {\n  return alignValue(trimValue(val, props), props);\n}\n\nfunction alignValue(val, props) {\n  var valModStep = (val - props.min) % props.step;\n  var alignedValue = val - valModStep;\n\n  if (Math.abs(valModStep) * 2 >= props.step) {\n    alignedValue += valModStep > 0 ? props.step : -props.step;\n  }\n\n  return parseFloat(alignedValue.toFixed(5));\n}\n\nfunction trimValue(val, props) {\n  var trimmed = val;\n\n  if (trimmed <= props.min) {\n    trimmed = props.min;\n  }\n\n  if (trimmed >= props.max) {\n    trimmed = props.max;\n  }\n\n  return trimmed;\n}\n\nvar ReactSlider = /*#__PURE__*/function (_React$Component) {\n  _inheritsLoose__default[\"default\"](ReactSlider, _React$Component);\n\n  function ReactSlider(_props) {\n    var _this;\n\n    _this = _React$Component.call(this, _props) || this;\n\n    _this.onKeyUp = function () {\n      _this.onEnd();\n    };\n\n    _this.onMouseUp = function () {\n      _this.onEnd(_this.getMouseEventMap());\n    };\n\n    _this.onTouchEnd = function () {\n      _this.onEnd(_this.getTouchEventMap());\n    };\n\n    _this.onBlur = function () {\n      _this.setState({\n        index: -1\n      }, _this.onEnd(_this.getKeyDownEventMap()));\n    };\n\n    _this.onMouseMove = function (e) {\n      // Prevent controlled updates from happening while mouse is moving\n      _this.setState({\n        pending: true\n      });\n\n      var position = _this.getMousePosition(e);\n\n      var diffPosition = _this.getDiffPosition(position[0]);\n\n      var newValue = _this.getValueFromPosition(diffPosition);\n\n      _this.move(newValue);\n    };\n\n    _this.onTouchMove = function (e) {\n      if (e.touches.length > 1) {\n        return;\n      } // Prevent controlled updates from happending while touch is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      var position = _this.getTouchPosition(e);\n\n      if (typeof _this.isScrolling === 'undefined') {\n        var diffMainDir = position[0] - _this.startPosition[0];\n        var diffScrollDir = position[1] - _this.startPosition[1];\n        _this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n      }\n\n      if (_this.isScrolling) {\n        _this.setState({\n          index: -1\n        });\n\n        return;\n      }\n\n      var diffPosition = _this.getDiffPosition(position[0]);\n\n      var newValue = _this.getValueFromPosition(diffPosition);\n\n      _this.move(newValue);\n    };\n\n    _this.onKeyDown = function (e) {\n      if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\n        return;\n      } // Prevent controlled updates from happening while a key is pressed\n\n\n      _this.setState({\n        pending: true\n      });\n\n      switch (e.key) {\n        case 'ArrowLeft':\n        case 'ArrowDown':\n        case 'Left':\n        case 'Down':\n          e.preventDefault();\n\n          _this.moveDownByStep();\n\n          break;\n\n        case 'ArrowRight':\n        case 'ArrowUp':\n        case 'Right':\n        case 'Up':\n          e.preventDefault();\n\n          _this.moveUpByStep();\n\n          break;\n\n        case 'Home':\n          e.preventDefault();\n\n          _this.move(_this.props.min);\n\n          break;\n\n        case 'End':\n          e.preventDefault();\n\n          _this.move(_this.props.max);\n\n          break;\n\n        case 'PageDown':\n          e.preventDefault();\n\n          _this.moveDownByStep(_this.props.pageFn(_this.props.step));\n\n          break;\n\n        case 'PageUp':\n          e.preventDefault();\n\n          _this.moveUpByStep(_this.props.pageFn(_this.props.step));\n\n          break;\n      }\n    };\n\n    _this.onSliderMouseDown = function (e) {\n      // do nothing if disabled or right click\n      if (_this.props.disabled || e.button === 2) {\n        return;\n      } // Prevent controlled updates from happening while mouse is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      if (!_this.props.snapDragDisabled) {\n        var position = _this.getMousePosition(e);\n\n        _this.forceValueFromPosition(position[0], function (i) {\n          _this.start(i, position[0]);\n\n          addHandlers(_this.getMouseEventMap());\n        });\n      }\n\n      pauseEvent(e);\n    };\n\n    _this.onSliderClick = function (e) {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (_this.props.onSliderClick && !_this.hasMoved) {\n        var position = _this.getMousePosition(e);\n\n        var valueAtPos = trimAlignValue(_this.calcValue(_this.calcOffsetFromPosition(position[0])), _this.props);\n\n        _this.props.onSliderClick(valueAtPos);\n      }\n    };\n\n    _this.createOnKeyDown = function (i) {\n      return function (e) {\n        if (_this.props.disabled) {\n          return;\n        }\n\n        _this.start(i);\n\n        addHandlers(_this.getKeyDownEventMap());\n        pauseEvent(e);\n      };\n    };\n\n    _this.createOnMouseDown = function (i) {\n      return function (e) {\n        // do nothing if disabled or right click\n        if (_this.props.disabled || e.button === 2) {\n          return;\n        } // Prevent controlled updates from happending while mouse is moving\n\n\n        _this.setState({\n          pending: true\n        });\n\n        var position = _this.getMousePosition(e);\n\n        _this.start(i, position[0]);\n\n        addHandlers(_this.getMouseEventMap());\n        pauseEvent(e);\n      };\n    };\n\n    _this.createOnTouchStart = function (i) {\n      return function (e) {\n        if (_this.props.disabled || e.touches.length > 1) {\n          return;\n        } // Prevent controlled updates from happending while touch is moving\n\n\n        _this.setState({\n          pending: true\n        });\n\n        var position = _this.getTouchPosition(e);\n\n        _this.startPosition = position; // don't know yet if the user is trying to scroll\n\n        _this.isScrolling = undefined;\n\n        _this.start(i, position[0]);\n\n        addHandlers(_this.getTouchEventMap());\n        stopPropagation(e);\n      };\n    };\n\n    _this.handleResize = function () {\n      // setTimeout of 0 gives element enough time to have assumed its new size if\n      // it is being resized\n      var resizeTimeout = window.setTimeout(function () {\n        // drop this timeout from pendingResizeTimeouts to reduce memory usage\n        _this.pendingResizeTimeouts.shift();\n\n        _this.resize();\n      }, 0);\n\n      _this.pendingResizeTimeouts.push(resizeTimeout);\n    };\n\n    _this.renderThumb = function (style, i) {\n      var className = _this.props.thumbClassName + \" \" + _this.props.thumbClassName + \"-\" + i + \" \" + (_this.state.index === i ? _this.props.thumbActiveClassName : '');\n      var props = {\n        'ref': function ref(r) {\n          _this[\"thumb\" + i] = r;\n        },\n        'key': _this.props.thumbClassName + \"-\" + i,\n        className: className,\n        style: style,\n        'onMouseDown': _this.createOnMouseDown(i),\n        'onTouchStart': _this.createOnTouchStart(i),\n        'onFocus': _this.createOnKeyDown(i),\n        'tabIndex': 0,\n        'role': 'slider',\n        'aria-orientation': _this.props.orientation,\n        'aria-valuenow': _this.state.value[i],\n        'aria-valuemin': _this.props.min,\n        'aria-valuemax': _this.props.max,\n        'aria-label': Array.isArray(_this.props.ariaLabel) ? _this.props.ariaLabel[i] : _this.props.ariaLabel,\n        'aria-labelledby': Array.isArray(_this.props.ariaLabelledby) ? _this.props.ariaLabelledby[i] : _this.props.ariaLabelledby\n      };\n      var state = {\n        index: i,\n        value: prepareOutValue(_this.state.value),\n        valueNow: _this.state.value[i]\n      };\n\n      if (_this.props.ariaValuetext) {\n        props['aria-valuetext'] = typeof _this.props.ariaValuetext === 'string' ? _this.props.ariaValuetext : _this.props.ariaValuetext(state);\n      }\n\n      return _this.props.renderThumb(props, state);\n    };\n\n    _this.renderTrack = function (i, offsetFrom, offsetTo) {\n      var props = {\n        key: _this.props.trackClassName + \"-\" + i,\n        className: _this.props.trackClassName + \" \" + _this.props.trackClassName + \"-\" + i,\n        style: _this.buildTrackStyle(offsetFrom, _this.state.upperBound - offsetTo)\n      };\n      var state = {\n        index: i,\n        value: prepareOutValue(_this.state.value)\n      };\n      return _this.props.renderTrack(props, state);\n    };\n\n    var value = sanitizeInValue(_props.value);\n\n    if (!value.length) {\n      value = sanitizeInValue(_props.defaultValue);\n    } // array for storing resize timeouts ids\n\n\n    _this.pendingResizeTimeouts = [];\n    var zIndices = [];\n\n    for (var i = 0; i < value.length; i += 1) {\n      value[i] = trimAlignValue(value[i], _props);\n      zIndices.push(i);\n    }\n\n    _this.resizeObserver = null;\n    _this.resizeElementRef = /*#__PURE__*/React__default[\"default\"].createRef();\n    _this.state = {\n      index: -1,\n      upperBound: 0,\n      sliderLength: 0,\n      value: value,\n      zIndices: zIndices\n    };\n    return _this;\n  }\n\n  var _proto = ReactSlider.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (typeof window !== 'undefined') {\n      this.resizeObserver = new ResizeObserver(this.handleResize);\n      this.resizeObserver.observe(this.resizeElementRef.current);\n      this.resize();\n    }\n  } // Keep the internal `value` consistent with an outside `value` if present.\n  // This basically allows the slider to be a controlled component.\n  ;\n\n  ReactSlider.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    var value = sanitizeInValue(props.value);\n\n    if (!value.length) {\n      return null;\n    } // Do not allow controlled upates to happen while we have pending updates\n\n\n    if (state.pending) {\n      return null;\n    }\n\n    return {\n      value: value.map(function (item) {\n        return trimAlignValue(item, props);\n      })\n    };\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    // If an upperBound has not yet been determined (due to the component being hidden\n    // during the mount event, or during the last resize), then calculate it now\n    if (this.state.upperBound === 0) {\n      this.resize();\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.clearPendingResizeTimeouts();\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n  };\n\n  _proto.onEnd = function onEnd(eventMap) {\n    if (eventMap) {\n      removeHandlers(eventMap);\n    }\n\n    if (this.hasMoved) {\n      this.fireChangeEvent('onAfterChange');\n    } // Allow controlled updates to continue\n\n\n    this.setState({\n      pending: false\n    });\n    this.hasMoved = false;\n  };\n\n  _proto.getValue = function getValue() {\n    return prepareOutValue(this.state.value);\n  };\n\n  _proto.getClosestIndex = function getClosestIndex(pixelOffset) {\n    var minDist = Number.MAX_VALUE;\n    var closestIndex = -1;\n    var value = this.state.value;\n    var l = value.length;\n\n    for (var i = 0; i < l; i += 1) {\n      var offset = this.calcOffset(value[i]);\n      var dist = Math.abs(pixelOffset - offset);\n\n      if (dist < minDist) {\n        minDist = dist;\n        closestIndex = i;\n      }\n    }\n\n    return closestIndex;\n  };\n\n  _proto.getMousePosition = function getMousePosition(e) {\n    return [e[\"page\" + this.axisKey()], e[\"page\" + this.orthogonalAxisKey()]];\n  };\n\n  _proto.getTouchPosition = function getTouchPosition(e) {\n    var touch = e.touches[0];\n    return [touch[\"page\" + this.axisKey()], touch[\"page\" + this.orthogonalAxisKey()]];\n  };\n\n  _proto.getKeyDownEventMap = function getKeyDownEventMap() {\n    return {\n      keydown: this.onKeyDown,\n      keyup: this.onKeyUp,\n      focusout: this.onBlur\n    };\n  };\n\n  _proto.getMouseEventMap = function getMouseEventMap() {\n    return {\n      mousemove: this.onMouseMove,\n      mouseup: this.onMouseUp\n    };\n  };\n\n  _proto.getTouchEventMap = function getTouchEventMap() {\n    return {\n      touchmove: this.onTouchMove,\n      touchend: this.onTouchEnd\n    };\n  };\n\n  _proto.getValueFromPosition = function getValueFromPosition(position) {\n    var diffValue = position / (this.state.sliderLength - this.state.thumbSize) * (this.props.max - this.props.min);\n    return trimAlignValue(this.state.startValue + diffValue, this.props);\n  };\n\n  _proto.getDiffPosition = function getDiffPosition(position) {\n    var diffPosition = position - this.state.startPosition;\n\n    if (this.props.invert) {\n      diffPosition *= -1;\n    }\n\n    return diffPosition;\n  } // create the `keydown` handler for the i-th thumb\n  ;\n\n  _proto.resize = function resize() {\n    var slider = this.slider,\n        thumb = this.thumb0;\n\n    if (!slider || !thumb) {\n      return;\n    }\n\n    var sizeKey = this.sizeKey(); // For the slider size, we want to use the client width/height, excluding any borders\n\n    var sliderRect = slider.getBoundingClientRect();\n    var sliderSize = slider[sizeKey];\n    var sliderMax = sliderRect[this.posMaxKey()];\n    var sliderMin = sliderRect[this.posMinKey()]; // For the thumb size, we want to use the outer width/height, including any borders\n\n    var thumbRect = thumb.getBoundingClientRect();\n    var thumbSize = thumbRect[sizeKey.replace('client', '').toLowerCase()];\n    var upperBound = sliderSize - thumbSize;\n    var sliderLength = Math.abs(sliderMax - sliderMin);\n\n    if (this.state.upperBound !== upperBound || this.state.sliderLength !== sliderLength || this.state.thumbSize !== thumbSize) {\n      this.setState({\n        upperBound: upperBound,\n        sliderLength: sliderLength,\n        thumbSize: thumbSize\n      });\n    }\n  } // calculates the offset of a thumb in pixels based on its value.\n  ;\n\n  _proto.calcOffset = function calcOffset(value) {\n    var range = this.props.max - this.props.min;\n\n    if (range === 0) {\n      return 0;\n    }\n\n    var ratio = (value - this.props.min) / range;\n    return ratio * this.state.upperBound;\n  } // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.\n  ;\n\n  _proto.calcValue = function calcValue(offset) {\n    var ratio = offset / this.state.upperBound;\n    return ratio * (this.props.max - this.props.min) + this.props.min;\n  };\n\n  _proto.calcOffsetFromPosition = function calcOffsetFromPosition(position) {\n    var slider = this.slider;\n    var sliderRect = slider.getBoundingClientRect();\n    var sliderMax = sliderRect[this.posMaxKey()];\n    var sliderMin = sliderRect[this.posMinKey()]; // The `position` value passed in is the mouse position based on the window height.\n    // The slider bounding rect is based on the viewport, so we must add the window scroll\n    // offset to normalize the values.\n\n    var windowOffset = window[\"page\" + this.axisKey() + \"Offset\"];\n    var sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);\n    var pixelOffset = position - sliderStart;\n\n    if (this.props.invert) {\n      pixelOffset = this.state.sliderLength - pixelOffset;\n    }\n\n    pixelOffset -= this.state.thumbSize / 2;\n    return pixelOffset;\n  } // Snaps the nearest thumb to the value corresponding to `position`\n  // and calls `callback` with that thumb's index.\n  ;\n\n  _proto.forceValueFromPosition = function forceValueFromPosition(position, callback) {\n    var _this2 = this;\n\n    var pixelOffset = this.calcOffsetFromPosition(position);\n    var closestIndex = this.getClosestIndex(pixelOffset);\n    var nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props); // Clone this.state.value since we'll modify it temporarily\n    // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n\n    var value = this.state.value.slice();\n    value[closestIndex] = nextValue; // Prevents the slider from shrinking below `props.minDistance`\n\n    for (var i = 0; i < value.length - 1; i += 1) {\n      if (value[i + 1] - value[i] < this.props.minDistance) {\n        return;\n      }\n    }\n\n    this.fireChangeEvent('onBeforeChange');\n    this.hasMoved = true;\n    this.setState({\n      value: value\n    }, function () {\n      callback(closestIndex);\n\n      _this2.fireChangeEvent('onChange');\n    });\n  } // clear all pending timeouts to avoid error messages after unmounting\n  ;\n\n  _proto.clearPendingResizeTimeouts = function clearPendingResizeTimeouts() {\n    do {\n      var nextTimeout = this.pendingResizeTimeouts.shift();\n      clearTimeout(nextTimeout);\n    } while (this.pendingResizeTimeouts.length);\n  };\n\n  _proto.start = function start(i, position) {\n    var thumbRef = this[\"thumb\" + i];\n\n    if (thumbRef) {\n      thumbRef.focus();\n    }\n\n    var zIndices = this.state.zIndices; // remove wherever the element is\n\n    zIndices.splice(zIndices.indexOf(i), 1); // add to end\n\n    zIndices.push(i);\n    this.setState(function (prevState) {\n      return {\n        startValue: prevState.value[i],\n        startPosition: position !== undefined ? position : prevState.startPosition,\n        index: i,\n        zIndices: zIndices\n      };\n    });\n  };\n\n  _proto.moveUpByStep = function moveUpByStep(step) {\n    if (step === void 0) {\n      step = this.props.step;\n    }\n\n    var oldValue = this.state.value[this.state.index];\n    var newValue = trimAlignValue(oldValue + step, this.props);\n    this.move(Math.min(newValue, this.props.max));\n  };\n\n  _proto.moveDownByStep = function moveDownByStep(step) {\n    if (step === void 0) {\n      step = this.props.step;\n    }\n\n    var oldValue = this.state.value[this.state.index];\n    var newValue = trimAlignValue(oldValue - step, this.props);\n    this.move(Math.max(newValue, this.props.min));\n  };\n\n  _proto.move = function move(newValue) {\n    var _this$state = this.state,\n        index = _this$state.index,\n        value = _this$state.value;\n    var length = value.length; // Short circuit if the value is not changing\n\n    var oldValue = value[index];\n\n    if (newValue === oldValue) {\n      return;\n    } // Trigger only before the first movement\n\n\n    if (!this.hasMoved) {\n      this.fireChangeEvent('onBeforeChange');\n    }\n\n    this.hasMoved = true; // if \"pearling\" (= thumbs pushing each other) is disabled,\n    // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.\n\n    var _this$props = this.props,\n        pearling = _this$props.pearling,\n        max = _this$props.max,\n        min = _this$props.min,\n        minDistance = _this$props.minDistance;\n\n    if (!pearling) {\n      if (index > 0) {\n        var valueBefore = value[index - 1];\n\n        if (newValue < valueBefore + minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueBefore + minDistance;\n        }\n      }\n\n      if (index < length - 1) {\n        var valueAfter = value[index + 1];\n\n        if (newValue > valueAfter - minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueAfter - minDistance;\n        }\n      }\n    }\n\n    value[index] = newValue; // if \"pearling\" is enabled, let the current thumb push the pre- and succeeding thumbs.\n\n    if (pearling && length > 1) {\n      if (newValue > oldValue) {\n        this.pushSucceeding(value, minDistance, index);\n        trimSucceeding(length, value, minDistance, max);\n      } else if (newValue < oldValue) {\n        this.pushPreceding(value, minDistance, index);\n        trimPreceding(length, value, minDistance, min);\n      }\n    } // Normally you would use `shouldComponentUpdate`,\n    // but since the slider is a low-level component,\n    // the extra complexity might be worth the extra performance.\n\n\n    this.setState({\n      value: value\n    }, this.fireChangeEvent.bind(this, 'onChange'));\n  };\n\n  _proto.pushSucceeding = function pushSucceeding(value, minDistance, index) {\n    var i;\n    var padding;\n\n    for (i = index, padding = value[i] + minDistance; value[i + 1] !== null && padding > value[i + 1]; i += 1, padding = value[i] + minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i + 1] = alignValue(padding, this.props);\n    }\n  };\n\n  _proto.pushPreceding = function pushPreceding(value, minDistance, index) {\n    for (var i = index, padding = value[i] - minDistance; value[i - 1] !== null && padding < value[i - 1]; i -= 1, padding = value[i] - minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i - 1] = alignValue(padding, this.props);\n    }\n  };\n\n  _proto.axisKey = function axisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'Y';\n    } // Defaults to 'horizontal';\n\n\n    return 'X';\n  };\n\n  _proto.orthogonalAxisKey = function orthogonalAxisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'X';\n    } // Defaults to 'horizontal'\n\n\n    return 'Y';\n  };\n\n  _proto.posMinKey = function posMinKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'bottom' : 'top';\n    } // Defaults to 'horizontal'\n\n\n    return this.props.invert ? 'right' : 'left';\n  };\n\n  _proto.posMaxKey = function posMaxKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'top' : 'bottom';\n    } // Defaults to 'horizontal'\n\n\n    return this.props.invert ? 'left' : 'right';\n  };\n\n  _proto.sizeKey = function sizeKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'clientHeight';\n    } // Defaults to 'horizontal'\n\n\n    return 'clientWidth';\n  };\n\n  _proto.fireChangeEvent = function fireChangeEvent(event) {\n    if (this.props[event]) {\n      this.props[event](prepareOutValue(this.state.value), this.state.index);\n    }\n  };\n\n  _proto.buildThumbStyle = function buildThumbStyle(offset, i) {\n    var style = {\n      position: 'absolute',\n      touchAction: 'none',\n      willChange: this.state.index >= 0 ? this.posMinKey() : undefined,\n      zIndex: this.state.zIndices.indexOf(i) + 1\n    };\n    style[this.posMinKey()] = offset + \"px\";\n    return style;\n  };\n\n  _proto.buildTrackStyle = function buildTrackStyle(min, max) {\n    var obj = {\n      position: 'absolute',\n      willChange: this.state.index >= 0 ? this.posMinKey() + \",\" + this.posMaxKey() : undefined\n    };\n    obj[this.posMinKey()] = min;\n    obj[this.posMaxKey()] = max;\n    return obj;\n  };\n\n  _proto.buildMarkStyle = function buildMarkStyle(offset) {\n    var _ref;\n\n    return _ref = {\n      position: 'absolute'\n    }, _ref[this.posMinKey()] = offset, _ref;\n  };\n\n  _proto.renderThumbs = function renderThumbs(offset) {\n    var length = offset.length;\n    var styles = [];\n\n    for (var i = 0; i < length; i += 1) {\n      styles[i] = this.buildThumbStyle(offset[i], i);\n    }\n\n    var res = [];\n\n    for (var _i = 0; _i < length; _i += 1) {\n      res[_i] = this.renderThumb(styles[_i], _i);\n    }\n\n    return res;\n  };\n\n  _proto.renderTracks = function renderTracks(offset) {\n    var tracks = [];\n    var lastIndex = offset.length - 1;\n    tracks.push(this.renderTrack(0, 0, offset[0]));\n\n    for (var i = 0; i < lastIndex; i += 1) {\n      tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));\n    }\n\n    tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n    return tracks;\n  };\n\n  _proto.renderMarks = function renderMarks() {\n    var _this3 = this;\n\n    var marks = this.props.marks;\n    var range = this.props.max - this.props.min + 1;\n\n    if (typeof marks === 'boolean') {\n      marks = Array.from({\n        length: range\n      }).map(function (_, key) {\n        return key;\n      });\n    } else if (typeof marks === 'number') {\n      marks = Array.from({\n        length: range\n      }).map(function (_, key) {\n        return key;\n      }).filter(function (key) {\n        return key % marks === 0;\n      });\n    }\n\n    return marks.map(parseFloat).sort(function (a, b) {\n      return a - b;\n    }).map(function (mark) {\n      var offset = _this3.calcOffset(mark);\n\n      var props = {\n        key: mark,\n        className: _this3.props.markClassName,\n        style: _this3.buildMarkStyle(offset)\n      };\n      return _this3.props.renderMark(props);\n    });\n  };\n\n  _proto.render = function render() {\n    var _this4 = this;\n\n    var offset = [];\n    var value = this.state.value;\n    var l = value.length;\n\n    for (var i = 0; i < l; i += 1) {\n      offset[i] = this.calcOffset(value[i], i);\n    }\n\n    var tracks = this.props.withTracks ? this.renderTracks(offset) : null;\n    var thumbs = this.renderThumbs(offset);\n    var marks = this.props.marks ? this.renderMarks() : null;\n    return /*#__PURE__*/React__default[\"default\"].createElement('div', {\n      ref: function ref(r) {\n        _this4.slider = r;\n        _this4.resizeElementRef.current = r;\n      },\n      style: {\n        position: 'relative'\n      },\n      className: this.props.className + (this.props.disabled ? ' disabled' : ''),\n      onMouseDown: this.onSliderMouseDown,\n      onClick: this.onSliderClick\n    }, tracks, thumbs, marks);\n  };\n\n  return ReactSlider;\n}(React__default[\"default\"].Component);\n\nReactSlider.displayName = 'ReactSlider';\nReactSlider.defaultProps = {\n  min: 0,\n  max: 100,\n  step: 1,\n  pageFn: function pageFn(step) {\n    return step * 10;\n  },\n  minDistance: 0,\n  defaultValue: 0,\n  orientation: 'horizontal',\n  className: 'slider',\n  thumbClassName: 'thumb',\n  thumbActiveClassName: 'active',\n  trackClassName: 'track',\n  markClassName: 'mark',\n  withTracks: true,\n  pearling: false,\n  disabled: false,\n  snapDragDisabled: false,\n  invert: false,\n  marks: [],\n  renderThumb: function renderThumb(props) {\n    return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _extends__default[\"default\"]({}, props, {\n      __self: ReactSlider,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 353,\n        columnNumber: 31\n      }\n    }));\n  },\n  renderTrack: function renderTrack(props) {\n    return /*#__PURE__*/React__default[\"default\"].createElement(\"div\", _extends__default[\"default\"]({}, props, {\n      __self: ReactSlider,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 354,\n        columnNumber: 31\n      }\n    }));\n  },\n  renderMark: function renderMark(props) {\n    return /*#__PURE__*/React__default[\"default\"].createElement(\"span\", _extends__default[\"default\"]({}, props, {\n      __self: ReactSlider,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 355,\n        columnNumber: 30\n      }\n    }));\n  }\n};\nReactSlider.propTypes = process.env.NODE_ENV !== \"production\" ? {\n  /**\n   * The minimum value of the slider.\n   */\n  min: PropTypes__default[\"default\"].number,\n\n  /**\n   * The maximum value of the slider.\n   */\n  max: PropTypes__default[\"default\"].number,\n\n  /**\n   * Value to be added or subtracted on each step the slider makes.\n   * Must be greater than zero.\n   * `max - min` should be evenly divisible by the step value.\n   */\n  step: PropTypes__default[\"default\"].number,\n\n  /**\n   * The result of the function is the value to be added or subtracted\n   * when the `Page Up` or `Page Down` keys are pressed.\n   *\n   * The current `step` value will be passed as the only argument.\n   * By default, paging will modify `step` by a factor of 10.\n   */\n  pageFn: PropTypes__default[\"default\"].func,\n\n  /**\n   * The minimal distance between any pair of thumbs.\n   * Must be positive, but zero means they can sit on top of each other.\n   */\n  minDistance: PropTypes__default[\"default\"].number,\n\n  /**\n   * Determines the initial positions of the thumbs and the number of thumbs.\n   *\n   * If a number is passed a slider with one thumb will be rendered.\n   * If an array is passed each value will determine the position of one thumb.\n   * The values in the array must be sorted.\n   */\n  defaultValue: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].number)]),\n\n  /**\n   * Like `defaultValue` but for\n   * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  value: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].number, PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].number)]),\n\n  /**\n   * Determines whether the slider moves horizontally (from left to right)\n   * or vertically (from top to bottom).\n   */\n  orientation: PropTypes__default[\"default\"].oneOf(['horizontal', 'vertical']),\n\n  /**\n   * The css class set on the slider node.\n   */\n  className: PropTypes__default[\"default\"].string,\n\n  /**\n   * The css class set on each thumb node.\n   *\n   * In addition each thumb will receive a numbered css class of the form\n   * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...\n   */\n  thumbClassName: PropTypes__default[\"default\"].string,\n\n  /**\n   * The css class set on the thumb that is currently being moved.\n   */\n  thumbActiveClassName: PropTypes__default[\"default\"].string,\n\n  /**\n   * If `true` tracks between the thumbs will be rendered.\n   */\n  withTracks: PropTypes__default[\"default\"].bool,\n\n  /**\n   * The css class set on the tracks between the thumbs.\n   * In addition track fragment will receive a numbered css class of the form\n   * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...\n   */\n  trackClassName: PropTypes__default[\"default\"].string,\n\n  /**\n   * If `true` the active thumb will push other thumbs\n   * within the constraints of `min`, `max`, `step` and `minDistance`.\n   */\n  pearling: PropTypes__default[\"default\"].bool,\n\n  /**\n   * If `true` the thumbs can't be moved.\n   */\n  disabled: PropTypes__default[\"default\"].bool,\n\n  /**\n   * Disables thumb move when clicking the slider track\n   */\n  snapDragDisabled: PropTypes__default[\"default\"].bool,\n\n  /**\n   * Inverts the slider.\n   */\n  invert: PropTypes__default[\"default\"].bool,\n\n  /**\n   * Shows passed marks on the track, if true it shows all the marks,\n   * if an array of numbers it shows just the passed marks, if a number is passed\n   * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9\n   */\n  marks: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].number), PropTypes__default[\"default\"].bool, PropTypes__default[\"default\"].number]),\n\n  /**\n   * The css class set on the marks.\n   */\n  markClassName: PropTypes__default[\"default\"].string,\n\n  /**\n   * Callback called before starting to move a thumb. The callback will only be called if the\n   * action will result in a change. The function will be called with two arguments, the first\n   * being the initial value(s) the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onBeforeChange: PropTypes__default[\"default\"].func,\n\n  /**\n   * Callback called on every value change.\n   * The function will be called with two arguments, the first being the new value(s)\n   * the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onChange: PropTypes__default[\"default\"].func,\n\n  /**\n   * Callback called only after moving a thumb has ended. The callback will only be called if\n   * the action resulted in a change. The function will be called with two arguments, the\n   * first being the result value(s) the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onAfterChange: PropTypes__default[\"default\"].func,\n\n  /**\n   * Callback called when the the slider is clicked (thumb or tracks).\n   * Receives the value at the clicked position as argument.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  onSliderClick: PropTypes__default[\"default\"].func,\n\n  /**\n   * aria-label for screen-readers to apply to the thumbs.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabel: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].string)]),\n\n  /**\n   * aria-labelledby for screen-readers to apply to the thumbs.\n   * Used when slider rendered with separate label.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabelledby: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].arrayOf(PropTypes__default[\"default\"].string)]),\n\n  /**\n   * aria-valuetext for screen-readers.\n   * Can be a static string, or a function that returns a string.\n   * The function will be passed a single argument,\n   * an object with the following properties:\n   *\n   *     state => `Value: ${state.value}`\n   *\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaValuetext: PropTypes__default[\"default\"].oneOfType([PropTypes__default[\"default\"].string, PropTypes__default[\"default\"].func]),\n\n  /**\n   * Provide a custom render function for the track node.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your handle node,\n   * and an object with track and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   * - `state.index` {`number`} the index of the track\n   * - `state.value` {`number` | `array`} the current value state\n   */\n  renderTrack: PropTypes__default[\"default\"].func,\n\n  /**\n   * Provide a custom render function for dynamic thumb content.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your thumb node,\n   * and an object with thumb and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your thumb node\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  renderThumb: PropTypes__default[\"default\"].func,\n\n  /**\n   * Provide a custom render function for the mark node.\n   * The render function will be passed one argument,\n   * an object with props that should be added to your handle node\n   *\n   *     (props) => <span {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   */\n  renderMark: PropTypes__default[\"default\"].func\n} : {};\nvar ReactSlider$1 = ReactSlider;\nexports[\"default\"] = ReactSlider$1;","map":{"version":3,"sources":["../../../../../src/components/ReactSlider/ReactSlider.jsx"],"names":["e","x","Array","i","padding","max","nextValue","length","min","Object","key","document","eventMap","alignValue","trimValue","valModStep","val","props","alignedValue","Math","parseFloat","trimmed","ReactSlider","React","Component","displayName","propTypes","PropTypes","step","pageFn","minDistance","defaultValue","value","orientation","className","thumbClassName","thumbActiveClassName","withTracks","trackClassName","pearling","disabled","snapDragDisabled","invert","marks","markClassName","onBeforeChange","onChange","onAfterChange","onSliderClick","ariaLabel","ariaLabelledby","ariaValuetext","renderTrack","renderThumb","renderMark","func","defaultProps","sanitizeInValue","pendingResizeTimeouts","zIndices","trimAlignValue","resizeObserver","index","upperBound","sliderLength","componentDidMount","getDerivedStateFromProps","state","item","componentDidUpdate","componentWillUnmount","onKeyUp","onMouseUp","getMouseEventMap","onTouchEnd","getTouchEventMap","onBlur","onEnd","getKeyDownEventMap","removeHandlers","pending","onMouseMove","position","diffPosition","getDiffPosition","newValue","move","onTouchMove","diffMainDir","startPosition","diffScrollDir","onKeyDown","moveDownByStep","moveUpByStep","onSliderMouseDown","forceValueFromPosition","addHandlers","pauseEvent","valueAtPos","calcValue","calcOffsetFromPosition","getValue","prepareOutValue","getClosestIndex","pixelOffset","minDist","Number","closestIndex","l","offset","dist","getMousePosition","getTouchPosition","touch","keydown","keyup","focusout","mousemove","mouseup","touchmove","touchend","getValueFromPosition","diffValue","start","isScrolling","stopPropagation","handleResize","resizeTimeout","resize","thumb0","thumb","sizeKey","sliderRect","slider","sliderSize","sliderMax","sliderMin","thumbRect","thumbSize","calcOffset","range","ratio","windowOffset","window","sliderStart","callback","fireChangeEvent","clearPendingResizeTimeouts","nextTimeout","clearTimeout","thumbRef","prevState","startValue","oldValue","valueBefore","valueAfter","trimSucceeding","trimPreceding","pushSucceeding","pushPreceding","axisKey","orthogonalAxisKey","posMinKey","posMaxKey","event","buildThumbStyle","style","touchAction","willChange","zIndex","buildTrackStyle","obj","undefined","buildMarkStyle","r","createOnMouseDown","createOnTouchStart","createOnKeyDown","valueNow","renderThumbs","styles","res","renderTracks","tracks","lastIndex","renderMarks","a","mark","render","thumbs","ref","onMouseDown","onClick"],"mappings":"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","sourcesContent":["import React from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * To prevent text selection while dragging.\n * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\n */\nfunction pauseEvent(e) {\n    if (e && e.stopPropagation) {\n        e.stopPropagation();\n    }\n    if (e && e.preventDefault) {\n        e.preventDefault();\n    }\n    return false;\n}\n\nfunction stopPropagation(e) {\n    if (e.stopPropagation) {\n        e.stopPropagation();\n    }\n}\n\nfunction sanitizeInValue(x) {\n    if (x == null) {\n        return [];\n    }\n    return Array.isArray(x) ? x.slice() : [x];\n}\n\nfunction prepareOutValue(x) {\n    return x !== null && x.length === 1 ? x[0] : x.slice();\n}\n\nfunction trimSucceeding(length, nextValue, minDistance, max) {\n    for (let i = 0; i < length; i += 1) {\n        const padding = max - i * minDistance;\n        if (nextValue[length - 1 - i] > padding) {\n            // eslint-disable-next-line no-param-reassign\n            nextValue[length - 1 - i] = padding;\n        }\n    }\n}\n\nfunction trimPreceding(length, nextValue, minDistance, min) {\n    for (let i = 0; i < length; i += 1) {\n        const padding = min + i * minDistance;\n        if (nextValue[i] < padding) {\n            // eslint-disable-next-line no-param-reassign\n            nextValue[i] = padding;\n        }\n    }\n}\n\nfunction addHandlers(eventMap) {\n    Object.keys(eventMap).forEach(key => {\n        if (typeof document !== 'undefined') {\n            document.addEventListener(key, eventMap[key], false);\n        }\n    });\n}\n\nfunction removeHandlers(eventMap) {\n    Object.keys(eventMap).forEach(key => {\n        if (typeof document !== 'undefined') {\n            document.removeEventListener(key, eventMap[key], false);\n        }\n    });\n}\n\nfunction trimAlignValue(val, props) {\n    return alignValue(trimValue(val, props), props);\n}\n\nfunction alignValue(val, props) {\n    const valModStep = (val - props.min) % props.step;\n    let alignedValue = val - valModStep;\n\n    if (Math.abs(valModStep) * 2 >= props.step) {\n        alignedValue += valModStep > 0 ? props.step : -props.step;\n    }\n\n    return parseFloat(alignedValue.toFixed(5));\n}\n\nfunction trimValue(val, props) {\n    let trimmed = val;\n    if (trimmed <= props.min) {\n        trimmed = props.min;\n    }\n    if (trimmed >= props.max) {\n        trimmed = props.max;\n    }\n\n    return trimmed;\n}\n\nclass ReactSlider extends React.Component {\n    static displayName = 'ReactSlider';\n\n    static propTypes = {\n        /**\n         * The minimum value of the slider.\n         */\n        min: PropTypes.number,\n\n        /**\n         * The maximum value of the slider.\n         */\n        max: PropTypes.number,\n\n        /**\n         * Value to be added or subtracted on each step the slider makes.\n         * Must be greater than zero.\n         * `max - min` should be evenly divisible by the step value.\n         */\n        step: PropTypes.number,\n\n        /**\n         * The result of the function is the value to be added or subtracted\n         * when the `Page Up` or `Page Down` keys are pressed.\n         *\n         * The current `step` value will be passed as the only argument.\n         * By default, paging will modify `step` by a factor of 10.\n         */\n        pageFn: PropTypes.func,\n\n        /**\n         * The minimal distance between any pair of thumbs.\n         * Must be positive, but zero means they can sit on top of each other.\n         */\n        minDistance: PropTypes.number,\n\n        /**\n         * Determines the initial positions of the thumbs and the number of thumbs.\n         *\n         * If a number is passed a slider with one thumb will be rendered.\n         * If an array is passed each value will determine the position of one thumb.\n         * The values in the array must be sorted.\n         */\n        defaultValue: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n        /**\n         * Like `defaultValue` but for\n         * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        value: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),\n\n        /**\n         * Determines whether the slider moves horizontally (from left to right)\n         * or vertically (from top to bottom).\n         */\n        orientation: PropTypes.oneOf(['horizontal', 'vertical']),\n\n        /**\n         * The css class set on the slider node.\n         */\n        className: PropTypes.string,\n\n        /**\n         * The css class set on each thumb node.\n         *\n         * In addition each thumb will receive a numbered css class of the form\n         * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...\n         */\n        thumbClassName: PropTypes.string,\n\n        /**\n         * The css class set on the thumb that is currently being moved.\n         */\n        thumbActiveClassName: PropTypes.string,\n\n        /**\n         * If `true` tracks between the thumbs will be rendered.\n         */\n        withTracks: PropTypes.bool,\n\n        /**\n         * The css class set on the tracks between the thumbs.\n         * In addition track fragment will receive a numbered css class of the form\n         * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...\n         */\n        trackClassName: PropTypes.string,\n\n        /**\n         * If `true` the active thumb will push other thumbs\n         * within the constraints of `min`, `max`, `step` and `minDistance`.\n         */\n        pearling: PropTypes.bool,\n\n        /**\n         * If `true` the thumbs can't be moved.\n         */\n        disabled: PropTypes.bool,\n\n        /**\n         * Disables thumb move when clicking the slider track\n         */\n        snapDragDisabled: PropTypes.bool,\n\n        /**\n         * Inverts the slider.\n         */\n        invert: PropTypes.bool,\n\n        /**\n         * Shows passed marks on the track, if true it shows all the marks,\n         * if an array of numbers it shows just the passed marks, if a number is passed\n         * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9\n         */\n        marks: PropTypes.oneOfType([\n            PropTypes.arrayOf(PropTypes.number),\n            PropTypes.bool,\n            PropTypes.number,\n        ]),\n\n        /**\n         * The css class set on the marks.\n         */\n        markClassName: PropTypes.string,\n\n        /**\n         * Callback called before starting to move a thumb. The callback will only be called if the\n         * action will result in a change. The function will be called with two arguments, the first\n         * being the initial value(s) the second being thumb index.\n         */\n        // eslint-disable-next-line max-len\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n        onBeforeChange: PropTypes.func,\n\n        /**\n         * Callback called on every value change.\n         * The function will be called with two arguments, the first being the new value(s)\n         * the second being thumb index.\n         */\n        // eslint-disable-next-line max-len\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n        onChange: PropTypes.func,\n\n        /**\n         * Callback called only after moving a thumb has ended. The callback will only be called if\n         * the action resulted in a change. The function will be called with two arguments, the\n         * first being the result value(s) the second being thumb index.\n         */\n        // eslint-disable-next-line max-len\n        // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n        onAfterChange: PropTypes.func,\n\n        /**\n         * Callback called when the the slider is clicked (thumb or tracks).\n         * Receives the value at the clicked position as argument.\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        onSliderClick: PropTypes.func,\n\n        /**\n         * aria-label for screen-readers to apply to the thumbs.\n         * Use an array for more than one thumb.\n         * The length of the array must match the number of thumbs in the value array.\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        ariaLabel: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]),\n\n        /**\n         * aria-labelledby for screen-readers to apply to the thumbs.\n         * Used when slider rendered with separate label.\n         * Use an array for more than one thumb.\n         * The length of the array must match the number of thumbs in the value array.\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        ariaLabelledby: PropTypes.oneOfType([\n            PropTypes.string,\n            PropTypes.arrayOf(PropTypes.string),\n        ]),\n\n        /**\n         * aria-valuetext for screen-readers.\n         * Can be a static string, or a function that returns a string.\n         * The function will be passed a single argument,\n         * an object with the following properties:\n         *\n         *     state => `Value: ${state.value}`\n         *\n         * - `state.index` {`number`} the index of the thumb\n         * - `state.value` {`number` | `array`} the current value state\n         * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        ariaValuetext: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),\n\n        /**\n         * Provide a custom render function for the track node.\n         * The render function will be passed two arguments,\n         * an object with props that should be added to your handle node,\n         * and an object with track and slider state:\n         *\n         *     (props, state) => <div {...props} />\n         *\n         * - `props` {`object`} props to be spread into your track node\n         * - `state.index` {`number`} the index of the track\n         * - `state.value` {`number` | `array`} the current value state\n         */\n        renderTrack: PropTypes.func,\n\n        /**\n         * Provide a custom render function for dynamic thumb content.\n         * The render function will be passed two arguments,\n         * an object with props that should be added to your thumb node,\n         * and an object with thumb and slider state:\n         *\n         *     (props, state) => <div {...props} />\n         *\n         * - `props` {`object`} props to be spread into your thumb node\n         * - `state.index` {`number`} the index of the thumb\n         * - `state.value` {`number` | `array`} the current value state\n         * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n         */\n        // eslint-disable-next-line zillow/react/require-default-props\n        renderThumb: PropTypes.func,\n\n        /**\n         * Provide a custom render function for the mark node.\n         * The render function will be passed one argument,\n         * an object with props that should be added to your handle node\n         *\n         *     (props) => <span {...props} />\n         *\n         * - `props` {`object`} props to be spread into your track node\n         */\n        renderMark: PropTypes.func,\n    };\n\n    static defaultProps = {\n        min: 0,\n        max: 100,\n        step: 1,\n        pageFn: step => step * 10,\n        minDistance: 0,\n        defaultValue: 0,\n        orientation: 'horizontal',\n        className: 'slider',\n        thumbClassName: 'thumb',\n        thumbActiveClassName: 'active',\n        trackClassName: 'track',\n        markClassName: 'mark',\n        withTracks: true,\n        pearling: false,\n        disabled: false,\n        snapDragDisabled: false,\n        invert: false,\n        marks: [],\n        renderThumb: props => <div {...props} />,\n        renderTrack: props => <div {...props} />,\n        renderMark: props => <span {...props} />,\n    };\n\n    constructor(props) {\n        super(props);\n\n        let value = sanitizeInValue(props.value);\n        if (!value.length) {\n            value = sanitizeInValue(props.defaultValue);\n        }\n\n        // array for storing resize timeouts ids\n        this.pendingResizeTimeouts = [];\n\n        const zIndices = [];\n        for (let i = 0; i < value.length; i += 1) {\n            value[i] = trimAlignValue(value[i], props);\n            zIndices.push(i);\n        }\n\n        this.resizeObserver = null;\n        this.resizeElementRef = React.createRef();\n\n        this.state = {\n            index: -1,\n            upperBound: 0,\n            sliderLength: 0,\n            value,\n            zIndices,\n        };\n    }\n\n    componentDidMount() {\n        if (typeof window !== 'undefined') {\n            this.resizeObserver = new ResizeObserver(this.handleResize);\n            this.resizeObserver.observe(this.resizeElementRef.current);\n            this.resize();\n        }\n    }\n\n    // Keep the internal `value` consistent with an outside `value` if present.\n    // This basically allows the slider to be a controlled component.\n    static getDerivedStateFromProps(props, state) {\n        const value = sanitizeInValue(props.value);\n        if (!value.length) {\n            return null;\n        }\n\n        // Do not allow controlled upates to happen while we have pending updates\n        if (state.pending) {\n            return null;\n        }\n\n        return {\n            value: value.map(item => trimAlignValue(item, props)),\n        };\n    }\n\n    componentDidUpdate() {\n        // If an upperBound has not yet been determined (due to the component being hidden\n        // during the mount event, or during the last resize), then calculate it now\n        if (this.state.upperBound === 0) {\n            this.resize();\n        }\n    }\n\n    componentWillUnmount() {\n        this.clearPendingResizeTimeouts();\n        if (this.resizeObserver) {\n            this.resizeObserver.disconnect();\n        }\n    }\n\n    onKeyUp = () => {\n        this.onEnd();\n    };\n\n    onMouseUp = () => {\n        this.onEnd(this.getMouseEventMap());\n    };\n\n    onTouchEnd = () => {\n        this.onEnd(this.getTouchEventMap());\n    };\n\n    onBlur = () => {\n        this.setState({ index: -1 }, this.onEnd(this.getKeyDownEventMap()));\n    };\n\n    onEnd(eventMap) {\n        if (eventMap) {\n            removeHandlers(eventMap);\n        }\n        if (this.hasMoved) {\n            this.fireChangeEvent('onAfterChange');\n        }\n\n        // Allow controlled updates to continue\n        this.setState({ pending: false });\n\n        this.hasMoved = false;\n    }\n\n    onMouseMove = e => {\n        // Prevent controlled updates from happening while mouse is moving\n        this.setState({ pending: true });\n\n        const position = this.getMousePosition(e);\n        const diffPosition = this.getDiffPosition(position[0]);\n        const newValue = this.getValueFromPosition(diffPosition);\n        this.move(newValue);\n    };\n\n    onTouchMove = e => {\n        if (e.touches.length > 1) {\n            return;\n        }\n\n        // Prevent controlled updates from happending while touch is moving\n        this.setState({ pending: true });\n\n        const position = this.getTouchPosition(e);\n\n        if (typeof this.isScrolling === 'undefined') {\n            const diffMainDir = position[0] - this.startPosition[0];\n            const diffScrollDir = position[1] - this.startPosition[1];\n            this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n        }\n\n        if (this.isScrolling) {\n            this.setState({ index: -1 });\n            return;\n        }\n\n        const diffPosition = this.getDiffPosition(position[0]);\n        const newValue = this.getValueFromPosition(diffPosition);\n\n        this.move(newValue);\n    };\n\n    onKeyDown = e => {\n        if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\n            return;\n        }\n\n        // Prevent controlled updates from happening while a key is pressed\n        this.setState({ pending: true });\n\n        switch (e.key) {\n            case 'ArrowLeft':\n            case 'ArrowDown':\n            case 'Left':\n            case 'Down':\n                e.preventDefault();\n                this.moveDownByStep();\n                break;\n            case 'ArrowRight':\n            case 'ArrowUp':\n            case 'Right':\n            case 'Up':\n                e.preventDefault();\n                this.moveUpByStep();\n                break;\n            case 'Home':\n                e.preventDefault();\n                this.move(this.props.min);\n                break;\n            case 'End':\n                e.preventDefault();\n                this.move(this.props.max);\n                break;\n            case 'PageDown':\n                e.preventDefault();\n                this.moveDownByStep(this.props.pageFn(this.props.step));\n                break;\n            case 'PageUp':\n                e.preventDefault();\n                this.moveUpByStep(this.props.pageFn(this.props.step));\n                break;\n            default:\n        }\n    };\n\n    onSliderMouseDown = e => {\n        // do nothing if disabled or right click\n        if (this.props.disabled || e.button === 2) {\n            return;\n        }\n\n        // Prevent controlled updates from happening while mouse is moving\n        this.setState({ pending: true });\n\n        if (!this.props.snapDragDisabled) {\n            const position = this.getMousePosition(e);\n            this.forceValueFromPosition(position[0], i => {\n                this.start(i, position[0]);\n                addHandlers(this.getMouseEventMap());\n            });\n        }\n\n        pauseEvent(e);\n    };\n\n    onSliderClick = e => {\n        if (this.props.disabled) {\n            return;\n        }\n\n        if (this.props.onSliderClick && !this.hasMoved) {\n            const position = this.getMousePosition(e);\n            const valueAtPos = trimAlignValue(\n                this.calcValue(this.calcOffsetFromPosition(position[0])),\n                this.props\n            );\n            this.props.onSliderClick(valueAtPos);\n        }\n    };\n\n    getValue() {\n        return prepareOutValue(this.state.value);\n    }\n\n    getClosestIndex(pixelOffset) {\n        let minDist = Number.MAX_VALUE;\n        let closestIndex = -1;\n\n        const { value } = this.state;\n        const l = value.length;\n\n        for (let i = 0; i < l; i += 1) {\n            const offset = this.calcOffset(value[i]);\n            const dist = Math.abs(pixelOffset - offset);\n            if (dist < minDist) {\n                minDist = dist;\n                closestIndex = i;\n            }\n        }\n\n        return closestIndex;\n    }\n\n    getMousePosition(e) {\n        return [e[`page${this.axisKey()}`], e[`page${this.orthogonalAxisKey()}`]];\n    }\n\n    getTouchPosition(e) {\n        const touch = e.touches[0];\n        return [touch[`page${this.axisKey()}`], touch[`page${this.orthogonalAxisKey()}`]];\n    }\n\n    getKeyDownEventMap() {\n        return {\n            keydown: this.onKeyDown,\n            keyup: this.onKeyUp,\n            focusout: this.onBlur,\n        };\n    }\n\n    getMouseEventMap() {\n        return {\n            mousemove: this.onMouseMove,\n            mouseup: this.onMouseUp,\n        };\n    }\n\n    getTouchEventMap() {\n        return {\n            touchmove: this.onTouchMove,\n            touchend: this.onTouchEnd,\n        };\n    }\n\n    getValueFromPosition(position) {\n        const diffValue =\n            (position / (this.state.sliderLength - this.state.thumbSize)) *\n            (this.props.max - this.props.min);\n        return trimAlignValue(this.state.startValue + diffValue, this.props);\n    }\n\n    getDiffPosition(position) {\n        let diffPosition = position - this.state.startPosition;\n        if (this.props.invert) {\n            diffPosition *= -1;\n        }\n        return diffPosition;\n    }\n\n    // create the `keydown` handler for the i-th thumb\n    createOnKeyDown = i => e => {\n        if (this.props.disabled) {\n            return;\n        }\n        this.start(i);\n        addHandlers(this.getKeyDownEventMap());\n        pauseEvent(e);\n    };\n\n    // create the `mousedown` handler for the i-th thumb\n    createOnMouseDown = i => e => {\n        // do nothing if disabled or right click\n        if (this.props.disabled || e.button === 2) {\n            return;\n        }\n\n        // Prevent controlled updates from happending while mouse is moving\n        this.setState({ pending: true });\n\n        const position = this.getMousePosition(e);\n        this.start(i, position[0]);\n        addHandlers(this.getMouseEventMap());\n        pauseEvent(e);\n    };\n\n    // create the `touchstart` handler for the i-th thumb\n    createOnTouchStart = i => e => {\n        if (this.props.disabled || e.touches.length > 1) {\n            return;\n        }\n\n        // Prevent controlled updates from happending while touch is moving\n        this.setState({ pending: true });\n\n        const position = this.getTouchPosition(e);\n        this.startPosition = position;\n        // don't know yet if the user is trying to scroll\n        this.isScrolling = undefined;\n        this.start(i, position[0]);\n        addHandlers(this.getTouchEventMap());\n        stopPropagation(e);\n    };\n\n    handleResize = () => {\n        // setTimeout of 0 gives element enough time to have assumed its new size if\n        // it is being resized\n        const resizeTimeout = window.setTimeout(() => {\n            // drop this timeout from pendingResizeTimeouts to reduce memory usage\n            this.pendingResizeTimeouts.shift();\n            this.resize();\n        }, 0);\n\n        this.pendingResizeTimeouts.push(resizeTimeout);\n    };\n\n    resize() {\n        const { slider, thumb0: thumb } = this;\n        if (!slider || !thumb) {\n            return;\n        }\n\n        const sizeKey = this.sizeKey();\n\n        // For the slider size, we want to use the client width/height, excluding any borders\n        const sliderRect = slider.getBoundingClientRect();\n        const sliderSize = slider[sizeKey];\n        const sliderMax = sliderRect[this.posMaxKey()];\n        const sliderMin = sliderRect[this.posMinKey()];\n\n        // For the thumb size, we want to use the outer width/height, including any borders\n        const thumbRect = thumb.getBoundingClientRect();\n        const thumbSize = thumbRect[sizeKey.replace('client', '').toLowerCase()];\n\n        const upperBound = sliderSize - thumbSize;\n        const sliderLength = Math.abs(sliderMax - sliderMin);\n\n        if (\n            this.state.upperBound !== upperBound ||\n            this.state.sliderLength !== sliderLength ||\n            this.state.thumbSize !== thumbSize\n        ) {\n            this.setState({\n                upperBound,\n                sliderLength,\n                thumbSize,\n            });\n        }\n    }\n\n    // calculates the offset of a thumb in pixels based on its value.\n    calcOffset(value) {\n        const range = this.props.max - this.props.min;\n        if (range === 0) {\n            return 0;\n        }\n        const ratio = (value - this.props.min) / range;\n        return ratio * this.state.upperBound;\n    }\n\n    // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.\n    calcValue(offset) {\n        const ratio = offset / this.state.upperBound;\n        return ratio * (this.props.max - this.props.min) + this.props.min;\n    }\n\n    calcOffsetFromPosition(position) {\n        const { slider } = this;\n\n        const sliderRect = slider.getBoundingClientRect();\n        const sliderMax = sliderRect[this.posMaxKey()];\n        const sliderMin = sliderRect[this.posMinKey()];\n\n        // The `position` value passed in is the mouse position based on the window height.\n        // The slider bounding rect is based on the viewport, so we must add the window scroll\n        // offset to normalize the values.\n        const windowOffset = window[`page${this.axisKey()}Offset`];\n        const sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);\n\n        let pixelOffset = position - sliderStart;\n        if (this.props.invert) {\n            pixelOffset = this.state.sliderLength - pixelOffset;\n        }\n        pixelOffset -= this.state.thumbSize / 2;\n        return pixelOffset;\n    }\n\n    // Snaps the nearest thumb to the value corresponding to `position`\n    // and calls `callback` with that thumb's index.\n    forceValueFromPosition(position, callback) {\n        const pixelOffset = this.calcOffsetFromPosition(position);\n        const closestIndex = this.getClosestIndex(pixelOffset);\n        const nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props);\n\n        // Clone this.state.value since we'll modify it temporarily\n        // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n        const value = this.state.value.slice();\n        value[closestIndex] = nextValue;\n\n        // Prevents the slider from shrinking below `props.minDistance`\n        for (let i = 0; i < value.length - 1; i += 1) {\n            if (value[i + 1] - value[i] < this.props.minDistance) {\n                return;\n            }\n        }\n\n        this.fireChangeEvent('onBeforeChange');\n        this.hasMoved = true;\n        this.setState({ value }, () => {\n            callback(closestIndex);\n            this.fireChangeEvent('onChange');\n        });\n    }\n\n    // clear all pending timeouts to avoid error messages after unmounting\n    clearPendingResizeTimeouts() {\n        do {\n            const nextTimeout = this.pendingResizeTimeouts.shift();\n\n            clearTimeout(nextTimeout);\n        } while (this.pendingResizeTimeouts.length);\n    }\n\n    start(i, position) {\n        const thumbRef = this[`thumb${i}`];\n        if (thumbRef) {\n            thumbRef.focus();\n        }\n\n        const { zIndices } = this.state;\n        // remove wherever the element is\n        zIndices.splice(zIndices.indexOf(i), 1);\n        // add to end\n        zIndices.push(i);\n\n        this.setState(prevState => ({\n            startValue: prevState.value[i],\n            startPosition: position !== undefined ? position : prevState.startPosition,\n            index: i,\n            zIndices,\n        }));\n    }\n\n    moveUpByStep(step = this.props.step) {\n        const oldValue = this.state.value[this.state.index];\n        const newValue = trimAlignValue(oldValue + step, this.props);\n        this.move(Math.min(newValue, this.props.max));\n    }\n\n    moveDownByStep(step = this.props.step) {\n        const oldValue = this.state.value[this.state.index];\n        const newValue = trimAlignValue(oldValue - step, this.props);\n        this.move(Math.max(newValue, this.props.min));\n    }\n\n    move(newValue) {\n        const { index, value } = this.state;\n        const { length } = value;\n\n        // Short circuit if the value is not changing\n        const oldValue = value[index];\n        if (newValue === oldValue) {\n            return;\n        }\n\n        // Trigger only before the first movement\n        if (!this.hasMoved) {\n            this.fireChangeEvent('onBeforeChange');\n        }\n        this.hasMoved = true;\n\n        // if \"pearling\" (= thumbs pushing each other) is disabled,\n        // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.\n        const { pearling, max, min, minDistance } = this.props;\n        if (!pearling) {\n            if (index > 0) {\n                const valueBefore = value[index - 1];\n                if (newValue < valueBefore + minDistance) {\n                    // eslint-disable-next-line no-param-reassign\n                    newValue = valueBefore + minDistance;\n                }\n            }\n\n            if (index < length - 1) {\n                const valueAfter = value[index + 1];\n                if (newValue > valueAfter - minDistance) {\n                    // eslint-disable-next-line no-param-reassign\n                    newValue = valueAfter - minDistance;\n                }\n            }\n        }\n\n        value[index] = newValue;\n\n        // if \"pearling\" is enabled, let the current thumb push the pre- and succeeding thumbs.\n        if (pearling && length > 1) {\n            if (newValue > oldValue) {\n                this.pushSucceeding(value, minDistance, index);\n                trimSucceeding(length, value, minDistance, max);\n            } else if (newValue < oldValue) {\n                this.pushPreceding(value, minDistance, index);\n                trimPreceding(length, value, minDistance, min);\n            }\n        }\n\n        // Normally you would use `shouldComponentUpdate`,\n        // but since the slider is a low-level component,\n        // the extra complexity might be worth the extra performance.\n        this.setState({ value }, this.fireChangeEvent.bind(this, 'onChange'));\n    }\n\n    pushSucceeding(value, minDistance, index) {\n        let i;\n        let padding;\n        for (\n            i = index, padding = value[i] + minDistance;\n            value[i + 1] !== null && padding > value[i + 1];\n            i += 1, padding = value[i] + minDistance\n        ) {\n            // eslint-disable-next-line no-param-reassign\n            value[i + 1] = alignValue(padding, this.props);\n        }\n    }\n\n    pushPreceding(value, minDistance, index) {\n        for (\n            let i = index, padding = value[i] - minDistance;\n            value[i - 1] !== null && padding < value[i - 1];\n            i -= 1, padding = value[i] - minDistance\n        ) {\n            // eslint-disable-next-line no-param-reassign\n            value[i - 1] = alignValue(padding, this.props);\n        }\n    }\n\n    axisKey() {\n        if (this.props.orientation === 'vertical') {\n            return 'Y';\n        }\n        // Defaults to 'horizontal';\n        return 'X';\n    }\n\n    orthogonalAxisKey() {\n        if (this.props.orientation === 'vertical') {\n            return 'X';\n        }\n        // Defaults to 'horizontal'\n        return 'Y';\n    }\n\n    posMinKey() {\n        if (this.props.orientation === 'vertical') {\n            return this.props.invert ? 'bottom' : 'top';\n        }\n        // Defaults to 'horizontal'\n        return this.props.invert ? 'right' : 'left';\n    }\n\n    posMaxKey() {\n        if (this.props.orientation === 'vertical') {\n            return this.props.invert ? 'top' : 'bottom';\n        }\n        // Defaults to 'horizontal'\n        return this.props.invert ? 'left' : 'right';\n    }\n\n    sizeKey() {\n        if (this.props.orientation === 'vertical') {\n            return 'clientHeight';\n        }\n        // Defaults to 'horizontal'\n        return 'clientWidth';\n    }\n\n    fireChangeEvent(event) {\n        if (this.props[event]) {\n            this.props[event](prepareOutValue(this.state.value), this.state.index);\n        }\n    }\n\n    buildThumbStyle(offset, i) {\n        const style = {\n            position: 'absolute',\n            touchAction: 'none',\n            willChange: this.state.index >= 0 ? this.posMinKey() : undefined,\n            zIndex: this.state.zIndices.indexOf(i) + 1,\n        };\n        style[this.posMinKey()] = `${offset}px`;\n        return style;\n    }\n\n    buildTrackStyle(min, max) {\n        const obj = {\n            position: 'absolute',\n            willChange:\n                this.state.index >= 0 ? `${this.posMinKey()},${this.posMaxKey()}` : undefined,\n        };\n        obj[this.posMinKey()] = min;\n        obj[this.posMaxKey()] = max;\n        return obj;\n    }\n\n    buildMarkStyle(offset) {\n        return {\n            position: 'absolute',\n            [this.posMinKey()]: offset,\n        };\n    }\n\n    renderThumb = (style, i) => {\n        const className = `${this.props.thumbClassName} ${this.props.thumbClassName}-${i} ${\n            this.state.index === i ? this.props.thumbActiveClassName : ''\n        }`;\n\n        const props = {\n            'ref': r => {\n                this[`thumb${i}`] = r;\n            },\n            'key': `${this.props.thumbClassName}-${i}`,\n            className,\n            style,\n            'onMouseDown': this.createOnMouseDown(i),\n            'onTouchStart': this.createOnTouchStart(i),\n            'onFocus': this.createOnKeyDown(i),\n            'tabIndex': 0,\n            'role': 'slider',\n            'aria-orientation': this.props.orientation,\n            'aria-valuenow': this.state.value[i],\n            'aria-valuemin': this.props.min,\n            'aria-valuemax': this.props.max,\n            'aria-label': Array.isArray(this.props.ariaLabel)\n                ? this.props.ariaLabel[i]\n                : this.props.ariaLabel,\n            'aria-labelledby': Array.isArray(this.props.ariaLabelledby)\n                ? this.props.ariaLabelledby[i]\n                : this.props.ariaLabelledby,\n        };\n\n        const state = {\n            index: i,\n            value: prepareOutValue(this.state.value),\n            valueNow: this.state.value[i],\n        };\n\n        if (this.props.ariaValuetext) {\n            props['aria-valuetext'] =\n                typeof this.props.ariaValuetext === 'string'\n                    ? this.props.ariaValuetext\n                    : this.props.ariaValuetext(state);\n        }\n\n        return this.props.renderThumb(props, state);\n    };\n\n    renderThumbs(offset) {\n        const { length } = offset;\n\n        const styles = [];\n        for (let i = 0; i < length; i += 1) {\n            styles[i] = this.buildThumbStyle(offset[i], i);\n        }\n\n        const res = [];\n        for (let i = 0; i < length; i += 1) {\n            res[i] = this.renderThumb(styles[i], i);\n        }\n        return res;\n    }\n\n    renderTrack = (i, offsetFrom, offsetTo) => {\n        const props = {\n            key: `${this.props.trackClassName}-${i}`,\n            className: `${this.props.trackClassName} ${this.props.trackClassName}-${i}`,\n            style: this.buildTrackStyle(offsetFrom, this.state.upperBound - offsetTo),\n        };\n        const state = {\n            index: i,\n            value: prepareOutValue(this.state.value),\n        };\n        return this.props.renderTrack(props, state);\n    };\n\n    renderTracks(offset) {\n        const tracks = [];\n        const lastIndex = offset.length - 1;\n\n        tracks.push(this.renderTrack(0, 0, offset[0]));\n\n        for (let i = 0; i < lastIndex; i += 1) {\n            tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));\n        }\n\n        tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n\n        return tracks;\n    }\n\n    renderMarks() {\n        let { marks } = this.props;\n\n        const range = this.props.max - this.props.min + 1;\n\n        if (typeof marks === 'boolean') {\n            marks = Array.from({ length: range }).map((_, key) => key);\n        } else if (typeof marks === 'number') {\n            marks = Array.from({ length: range })\n                .map((_, key) => key)\n                .filter(key => key % marks === 0);\n        }\n\n        return marks\n            .map(parseFloat)\n            .sort((a, b) => a - b)\n            .map(mark => {\n                const offset = this.calcOffset(mark);\n\n                const props = {\n                    key: mark,\n                    className: this.props.markClassName,\n                    style: this.buildMarkStyle(offset),\n                };\n\n                return this.props.renderMark(props);\n            });\n    }\n\n    render() {\n        const offset = [];\n        const { value } = this.state;\n        const l = value.length;\n        for (let i = 0; i < l; i += 1) {\n            offset[i] = this.calcOffset(value[i], i);\n        }\n\n        const tracks = this.props.withTracks ? this.renderTracks(offset) : null;\n        const thumbs = this.renderThumbs(offset);\n        const marks = this.props.marks ? this.renderMarks() : null;\n\n        return React.createElement(\n            'div',\n            {\n                ref: r => {\n                    this.slider = r;\n                    this.resizeElementRef.current = r;\n                },\n                style: { position: 'relative' },\n                className: this.props.className + (this.props.disabled ? ' disabled' : ''),\n                onMouseDown: this.onSliderMouseDown,\n                onClick: this.onSliderClick,\n            },\n            tracks,\n            thumbs,\n            marks\n        );\n    }\n}\n\nexport default ReactSlider;\n"]},"metadata":{},"sourceType":"script"}